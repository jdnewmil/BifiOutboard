---
title: "Preliminary analysis"
author: Jeff Newmiller
date: 21 June 2024
format:
    html:
        self-contained: true
---

## Setup

```{python}
import pathlib
import collections
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotnine as p9
import bifi_outboard as bo  # bifi-captest development package
import bifi_outboard.captest_prototype.io as ctpio
import bifi_outboard.captest_prototype.model_ols as ctpmols
import bifi_outboard.captest_prototype.sim_study as ctpss
import bifi_outboard.captest_prototype.column_selection as ctpcs
import bifi_outboard.captest_prototype.captest_info as ctpci
```

## Simulation database

```{python}
dta_dir = pathlib.Path('..') / 'data'
shts = pd.read_excel(dta_dir / 'Inventory.xlsx', sheet_name=None, header=0)
shts['Sites'] = shts['Sites'].set_index('SiteLabel')
shts['Systems'] = shts['Systems'].set_index('SystemLabel')
shts['PVsyst Runs'] = shts['PVsyst Runs'].set_index(['prj_file', 'variant'])
```

```{python}
run_infos = (
    shts['PVsyst Runs']
    .join(other=shts['Systems'], how='left', on='SystemLabel')
    .join(other=shts['Sites'], how='left', on='SiteLabel'))
```

Only referring to one of the simulations in this document at this time:

```{python}
run_info = (
    run_infos
    .loc[('Test Bifi SAT_Project.PRJ', 'SAT Az0 (bifi)'), :])
```

## Mono regression

Treating a bifacial PV system simulation as though it were monofacial. Rear side irradiance acts as a bias offset and noise input.

### Retrieve sample bifacial simulation data

```{python}
ctdta = ctpio.read_pvsyst_hourly(
    dta_dir / run_info['Csvfile']
    , sep=run_info['sep']
    , dayfirst=run_info['dayfirst'])
ctdta
```

### Quality check the data records

```{python}
def year_begin(x: pd.Timestamp) -> pd.Timestamp:
    """Robust timestamp beginning of year function.
    """
    result = pd.Timestamp(year=x.year, month=1, day=1, tzinfo=x.tzinfo)
    return result

def find_sim_interval(
    idx: pd.DatetimeIndex
    , test_date: pd.Timestamp
    , days: int
    , wrap_year: bool = True
) -> pd.Series:
    dtm = idx
    days2 = int(days // 2)
    dts = dtm.floor('D')
    start = test_date - pd.Timedelta(days2, unit='D')
    end = test_date + pd.Timedelta(days - days2, unit='D')
    if wrap_year:
        dtm_ys = dtm.to_period('Y').to_timestamp()
        start = dtm_ys[0] + (start - year_begin(start))
        end = dtm_ys[0] + (end - year_begin(end))
    if start < end:
        result = (dtm >= start) & (dtm < end)
    else:
        result = (dtm < end) | (dtm >= start)
    return result

# # testing
# tst_series = pd.Series(
#     list(range(8760))
#     , index=pd.date_range('1990-01-01', periods=8760, freq='h'))
# tst_series.loc[find_sim_interval(tst_series.index, pd.Timestamp('1990-12-31'), 3)]
```

```{python}
ctdta_qc_col = pd.Series('Ok', index=ctdta.index)
ctdta_qc_col = ctdta_qc_col.where(
    find_sim_interval(ctdta.index, pd.Timestamp('1990-12-01'), 90)
    , 'Non-test season')
ctdta_qc_col = ctdta_qc_col.where(
    ctdta['ShdLoss'].le(10.0)
    , 'Array shading')
ctdta_qc_col = ctdta_qc_col.where(
    ctdta['GlobInc'].ge(400.0), 'Low GlobInc')
ctdta_qc_col = ctdta_qc_col.where(
    ctdta['EOutInv'].le(0.995 * ctdta['EOutInv'].max()), 'Clipped power')
ctdta_qc_col = pd.Categorical(
    ctdta_qc_col
    , categories=['Ok', 'Low GlobInc', 'Clipped power', 'Array shading', 'Non-test season'])
qc_ctdta = ctdta.loc[ctdta_qc_col == 'Ok', :]
qc_ctdta
```

```{python}
(
    p9.ggplot(
        ctdta.assign(QC=ctdta_qc_col)
        , p9.aes(x='GlobInc', y='EOutInv', color='QC'))
    + p9.geom_point(size=1, alpha=0.5)
    + p9.scale_color_manual(values=['black', 'blue', 'red', 'green', 'yellow'])
).show()
```

The data records used for this fit are the ones listed as "Ok" here:

```{python}
pd.DataFrame(ctdta_qc_col.value_counts())
```

### Map column names to regression terms

An ASTM E2848 regression equation has four variables: `E` for plane-of-array irradiance, `T_a` for ambient temperature, `v` for wind speed, and `P` for system output power. The corresponding columns generated by PVsyst would be `GlobInc`, `T_Amb`, `WindVel`, and `EOutInv`. The `captest_prototype` includes a model specification format that allows one or more columns to be multiplied by coefficients and added... in this case, including one PVsyst variable name with a multiplier of 1.0 makes the variable names expected by the linear regression available for the regression as 1.0 times the corresponding simulation variable.

```{python}
scc_mono = {
    'E': ctpcs.SCADAComputedColumn(
        computed_function='Linear'
        , computed_value_columns={'GlobInc': 1.0}
        , cf_params={})
    , 'T_a': ctpcs.SCADAComputedColumn(
        computed_function='Linear'
        , computed_value_columns={'T_Amb': 1.0}
        , cf_params={})
    , 'v': ctpcs.SCADAComputedColumn(
        computed_function='Linear'
        , computed_value_columns={'WindVel': 1.0}
        , cf_params={})
    , 'P': ctpcs.SCADAComputedColumn(
        computed_function='Linear'
        , computed_value_columns={'EOutInv': 1.0}
        , cf_params={})
}
```

### Declare reference conditions

Reference conditions can be calculated automatically, but there can be a variety of ways to do that. For this initial demo, we use a pre-defined set of environmental exposure conditions.

```{python}
mrcs_mono1 = ctpci.ModelOLSRCSpec(
    reference_spec=ctpci.FixedReferenceCondition(
        reference_inputs={
            'E': 605, 'T_a': 20.0, 'v': 3.5})
    , conf_level=0.95
    , **ctpci.default_model_info['ASTM_E2848'])
```

For reference, here is what the default model info contains:

```{python}
ctpci.default_model_info['ASTM_E2848']
```

This large number of parameters to the reference conditions allows for considerable control over using different ordinary least-squares regression models. It is not required to refer to the `default_model_info` when creating a reference condition, but for standard models using the `default_model_info` lookup dictionary should limit the opportunity for errors.

### Declare the test info object

The test info defines how the capacity test will run. In general, a particular input like plane-of-array irradiance will be measured with redundant sensors, and it will be necessary to indicate which columns contain those raw values. In this case, there is no redundancy so `redundant_columns` is an empty set.

The computed columns introduced above can reference either columns from the raw data, or can reference column names introduced by the redundant combination of raw columns. In this case, `scc_mono` above defines new columns using the raw simulation column names, bypassing any redundancy.

```{python}
test_info_mono1 = ctpci.OLSCapTestInfo(
    model_rc_spec=mrcs_mono1
    , computed_set_data=ctpcs.QCComputedSetData(
        computed_columns=scc_mono
        , redundant_data=ctpcs.QCRedundantSetData(
            redundant_columns={})))

```

### Run the regression

The `captest_prototype` engine is geared to process multiple regressions (e.g. for monthly regressions) in a python generator pipeline. For a simple regression, you have to convert the input data frame into a sequence of one using the `onegroup` function, hand it off to the OLSCapTestInfo object to do the regression, and combine the pipeline of results (only one in this case).

```{python}
ctpci.mr_fitconf_combine(
    mr_out=test_info_mono1.model_runner(
        gdf=ctpci.onegroup(qc_ctdta)
        , model_extractor=ctpci.me_fitconf
        , gdf_columns=set(qc_ctdta.columns))
    , key_names=['One']
    , droplevel=True
)
```

Based on the default "P95" confidence level in `mrcs_mono1`, the result is a data frame with three columns:

- `fit`: provides the expected capacity value.
- `lwr`: a P2.5 prediction estimate (includes impact of residuals) representing the lower confidence value, and
- `upr`: a P97.5 prediction estimate (including impact of residuals) representing the upper confidence value.

### Regression diagnostics

We can also run the regression pipeline but keep all the intermediate results for diagnostics:

```{python}
mono_detail = {
    k: full_model
    for k, full_model in test_info_mono1.model_runner(
        gdf=ctpci.onegroup(qc_ctdta)
        , model_extractor=ctpci.full_model_extractor
        , gdf_columns=set(qc_ctdta.columns))
}[True]
```

A partial-regression plot [^1] illustrates which inputs have the largest residuals affecting the coefficients extracted:
```{python}
mono_detail.plot(method='partregress_grid');
```
Partial regression plot axes show power residuals vs. input variable residuals, which means they are referenced with zero corresponding to the predicted value of the corresponding variable.

An influence plot [^2] indicates which data records have the largest residuals and leverage on the final fit:

```{python}
mono_detail.plot(method='influence_plot');
```

A plot of power vs each of the regression inputs, along with a green band indicating the confidence interval for the regression fit. The differing range of power values in each facet reflects the differing impact each variable has on power.

```{python}
mono_detail.autoplot(method='partial_model')
```

## Bifi regression

Same simulation, but accounting for rear side outboard irradiance.

### Retrieve data

```{python}
bdta = ctdta.copy()
```

### Augment simulation data

For measured data, sensor readings can be directly used. For the simulation, a simulated outboard reading is needed.

A fundamental input is how far away from the edge of the array the rear-facing outboard sensor will be placed:

```{python}
base_offset = 0.5  # meters, because the height in run_info is in meters
```

Now we compute `E_rear_outboard`:

```{python}
bdta_aug = ctpss.augment_sim_data(
    er_df=bdta, run_info=run_info, offset=base_offset)
```

### Quality check data

```{python}
bdta_qc_col = pd.Series('Ok', index=bdta_aug.index)
bdta_qc_col = bdta_qc_col.where(
    bdta_aug['ShdLoss'].le(10.0)
    , 'Array shading')
bdta_qc_col = bdta_qc_col.where(
    find_sim_interval(bdta_aug.index, pd.Timestamp('1990-12-01'), 90)
    , 'Non-test season')
bdta_qc_col = bdta_qc_col.where(
    bdta_aug['E_rear_outboard'].ge(75.0), 'Low E_rear_outboard')
bdta_qc_col = bdta_qc_col.where(bdta_aug['GlobInc'].ge(400.0), 'Low GlobInc')
bdta_qc_col = bdta_qc_col.where(bdta_aug['EOutInv'].le(0.995 * bdta_aug['EOutInv'].max()), 'Clipped power')
bdta_qc_col = pd.Categorical(
    bdta_qc_col
    , categories=[
        'Ok', 'Low GlobInc', 'Clipped power', 'Array shading', 'Non-test season'
        , 'Low E_rear_outboard'])
qc_bdta_aug = bdta_aug.loc[bdta_qc_col == 'Ok', :]
qc_bdta_aug
```

```{python}
(
    p9.ggplot(
        bdta_aug.assign(QC=bdta_qc_col)
        , p9.aes(x='GlobInc', y='EOutInv', color='QC'))
    + p9.geom_point(size=1, alpha=0.5)
    + p9.scale_color_manual(values=['black', 'blue', 'red', 'green', 'yellow', 'orange'])
).show()
```

The number of data records used for this fit are the ones listed as "Ok" here:

```{python}
pd.DataFrame(bdta_qc_col.value_counts())
```

### Map column names to regression terms

This bifacial capacity test uses an augmented version of the ASTM E2848 regression equation

$$
\begin{aligned}
P &= (E_\mathrm{front} + E_\mathrm{rear}) \\
  &\cdot \left(
  a_1
  + a_\mathrm{2a} E_\mathrm{front}
  + a_\mathrm{2b} E_\mathrm{rear}
  + a_3 T_\mathrm{a}
  + a_4 v
  \right)
\end{aligned}
$$
which has five variables: `E_front` for front-side plane-of-array irradiance, `E_rear` for rear-side irradiance, `T_a` for ambient temperature, `v` for wind speed, and `P` for system output power. The corresponding data columns would be `GlobInc`, `E_rear_outboard`, `T_Amb`, `WindVel`, and `EOutInv`. 

```{python}
scc_bifi = {
    'E_front': ctpcs.SCADAComputedColumn(
        computed_function='Linear'
        , computed_value_columns={'GlobInc': 1.0}
        , cf_params={})
    , 'E_rear': ctpcs.SCADAComputedColumn(
        computed_function='Linear'
        , computed_value_columns={'E_rear_outboard': 1.0}
        , cf_params={})
    , 'T_a': ctpcs.SCADAComputedColumn(
        computed_function='Linear'
        , computed_value_columns={'T_Amb': 1.0}
        , cf_params={})
    , 'v': ctpcs.SCADAComputedColumn(
        computed_function='Linear'
        , computed_value_columns={'WindVel': 1.0}
        , cf_params={})
    , 'P': ctpcs.SCADAComputedColumn(
        computed_function='Linear'
        , computed_value_columns={'EOutInv': 1.0}
        , cf_params={})
}
```

### Declare reference conditions

Reference conditions can be calculated automatically, but there are a variety of ways to do that. For this initial demo, we use a pre-defined set of environmental exposure conditions.

```{python}
mrcs_bifi1 = ctpci.ModelOLSRCSpec(
    reference_spec=ctpci.FixedReferenceCondition(
        reference_inputs={
            'E_front': 605, 'E_rear': 90, 'T_a': 20.0, 'v': 3.5})
    , conf_level=0.95
    , **ctpci.default_model_info['DNV_Bifi_ASTM'])
```

For reference, here is what the default model info contains:

```{python}
ctpci.default_model_info['DNV_Bifi_ASTM']
```

### Declare the test info object

```{python}
test_info_bifi1 = ctpci.OLSCapTestInfo(
    model_rc_spec=mrcs_bifi1
    , computed_set_data=ctpcs.QCComputedSetData(
        computed_columns=scc_bifi
        , redundant_data=ctpcs.QCRedundantSetData(
            redundant_columns={})))
```

### Run the regression

The `captest_prototype engine` is geared to process multiple regressions (e.g. for monthly regressions) in a python generator pipeline. For a simple regression, you have to convert the input data frame into a sequence of one using the `onegroup` function, hand it off to the OLSCapTestInfo object to do the regression, and combine the pipeline of results (only one in this case).

```{python}
ctpci.mr_fitconf_combine(
    mr_out=test_info_bifi1.model_runner(
        gdf=ctpci.onegroup(qc_bdta_aug)
        , model_extractor=ctpci.me_fitconf
        , gdf_columns=set(qc_bdta_aug.columns))
    , key_names=['One']
    , droplevel=True
)
```

Notice that the monofacial and bifacial results do not match. This is because their respective reference conditions correspond to different amounts of input energy. However, when you repeat the bifacial regression with measured data and the same bifacial reference conditions, the resulting fit for the measured data should correspond to the fit for the simulation.

### Regression diagnostics

We can also run the regression pipeline but keep all the intermediate results for diagnostics:

```{python}
bifi_detail = {
    k: full_model
    for k, full_model in test_info_bifi1.model_runner(
        gdf=ctpci.onegroup(qc_bdta_aug)
        , model_extractor=ctpci.full_model_extractor
        , gdf_columns=set(qc_bdta_aug.columns))
}[True]
```

A partial-regression plot [^1] illustrates which inputs have the largest residuals affecting the coefficients extracted:

```{python}
bifi_detail.plot(method='partregress_grid');
```

An influence plot [^2] indicates which data records have the largest residuals and leverage on the final fit:

```{python}
bifi_detail.plot(method='influence_plot');
```

A plot of power vs each of the regression inputs, along with a green band indicating the confidence interval for the regression fit.

```{python}
bifi_detail.autoplot(method='partial_model')
```

Regressing using the bifacial model yields a narrower confidence interval on the capacity estimate than running a standard monofacial regression on a bifacial data set. If the comparison were made instead with `GlobCell` then the confidence interval would be even narrower but the result would then ignore failure to deliver the assumed bifaciality or rear structural shade loss.

[^1]: https://en.wikipedia.org/wiki/Partial_regression_plot
[^2]: https://stats.stackexchange.com/questions/602385/how-do-i-interpret-this-plot-and-summary-multivariable-linear-regression